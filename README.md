# intensive_on_python
решение задач на python

# Оглавление
1. [День 00](#день-00) \
    [Упражнение 00: Блокчейн](#упражнение-00-блокчейн)\
    [Упражнение 01: Расшифровка](#упражнение-01-расшифровка)\
    [Упражнение 02. Отслеживание и захват](#упражнение-02-отслеживание-и-захват)
2. [День 01](#день-01)\
    [Упражнение 00: Функциональный кошелек](#упражнение-00-функциональный-кошелек)\
    [Упражнение 01: Расщепление](#упражнение-01-расщепление)\
    [Упражнение 02: Охранная сигнализация](#упражнение-02-охранная-сигнализация)
3. [День 02](#день-02)\
    [Упражнение 00: Получение доступа](#упражнение-00-получение-доступа)\
    [Упражнение 01: Мораль](#упражнение-01-мораль)
4. [День 03](#день-03)\
    [Упражнение 00: Невинная шутка](#упражнение-00-невинная-шутка)\
    [Упражнение 01: Денежный поток](#упражнение-01-денежный-поток)
5. [День 04](#день-04)\
    [Упражнение 00: Поток энергии](#упражнение-00-поток-энергии)\
    [Упражнение 01: Личности](#упражнение-01-личности)\
    [Упражнение 02: Противодавление](#упражнение-02-противодавление)
6. [День 05](#день-05)\
    [Упражнение 00: Обмани меня один раз](#упражнение-00-обмани-меня-один-раз)\
    [Упражнение 01: Песня про отвертку](#упражнение-01-песня-про-отвертку)\
    [Упражнение 02. Правильное время](#упражнение-02-правильное-время)
7. [День 06](#день-06)\
    [Упражнение 00: Отчет по Кирову](#упражнение-00-отчет-по-кирову)


# День 00
## Упражнение 00: Блокчейн
Дан [файл](d00/data_hashes_10lines.txt), с несколькими строками. Некоторые строки начинаются с нескольких нулей. Нужно написать Python-скрипт, который сможет получать текст со своего стандартного ввода, а затем выводить только те строки, которые начинаются ровно с 5 нулей и строка имеет длину 32 символа. Строка, начинающаяся с 6 нулей, НЕ считается правильной.

Код должен принимать количество строк в качестве аргумента, например:
```
~$ cat data_hashes_10lines.txt | python blocks.py 10
```
Таким образом, программа остановится, когда обработает 10 строк. 

## Упражнение 01: Расшифровка
Электронные письма состояли из каких-то странных текстов, таких как "The only way everyone reaches Brenda rapidly is delivering groceries explicitly" или "Britain is Great because everyone necessitates". Написать скрипт на Python, который можно использовать для расшифровки подобных сообщений и распечатать ответ одним словом без пробелов. Он должен запускаться следующим образом:
```
~$ python decypher.py \"Have you delivered eggplant pizza at restored keep?\"
```

## Упражнение 02. Отслеживание и захват
В качестве входных данных коду дается двумерное «изображение» в виде текста в файле m.txt. Файл содержит пять символов в трех строках, например:
```
*d&t*
**h**
*l*!*
```
Есть шаблон из звезд с буквой M. Все, что нужно сделать — это напечатать «True», если этот M-шаблон существует в заданном входном изображении, или «False» в противном случае. Другие символы (за пределами шаблона M) должны быть другими, поэтому в этих примерах должно быть напечатано «False»:
```
*****
*****
*****
```
```
*s*f*
**f**
*a***
```
Если данный шаблон не 3x5, то вместо него должно быть напечатано слово «Error». Файл с кодом должен называться mfinder.py.

# День 01
## Упражнение 00: Функциональный кошелек
нужно написать функции `add_ingot(purse)`, `get_ingot(purse)`которые `empty(purse)` принимают кошелек (словарь, строго говоря, a `typing.Dict[str, int]`) и возвращают кошелек (пустой dict в случае `empty(purse)`). Им не следует делать предположений о содержимом кошелька (он может быть пустым или хранить что-то совсем другое, например «stones»).

Кроме того, ваши функции не должны иметь побочных эффектов. Это означает, что объект, переданный в качестве аргумента, не должен изменяться внутри функции. Вместо этого должен быть возвращен новый объект. Таким образом, *вам не следует использовать код, написанный Томом*, так как он делает *прямое присвоение* полю внутри кошелька. Вместо этого вы должны вернуть *новый экземпляр dict* с обновленным номером внутри него.

Итак, композиция функций вроде `add_ingot(get_ingot(add_ingot(empty(purse))))` должна возвращать `{\"gold_ingots\": 1}`. Кроме того, получение слитка из пустого кошелька не должно приводить к ошибке и должно просто возвращать пустой кошелек.

Примечание: в этой задаче нас интересуют только золотые слитки, так что не имеет особого значения, что будет с остальными вещами внутри кошелька. Вы можете сохранить его или выбросить.

## Упражнение 01: Расщепление
Вам нужно написать функцию с именем `split_booty`, которая будет принимать любое количество кошельков (словарей) в качестве аргументов. Кошельки в аргументах могут содержать различные предметы, но наших почетных деятелей интересуют только золотые слитки (названные, `gold_ingots` как в примерах выше). Количество слитков может быть нулевым или целым положительным числом.

Эта функция должна вернуть назад три кошелька (словаря) так, чтобы в любых двух из трех кошельков разница между количеством слитков была не больше 1. Например, если в добыче есть , и , то `{"gold_ingots":3}` функция `{"gold_ingots":2}` должна `{"apples":10}` вернуть `({"gold_ingots": 2}, {"gold_ingots": 2}, {"gold_ingots": 1})`.

При реализации этой функции вы все равно не должны использовать прямое присвоение полей внутри словарей. Вместо этого вы можете повторно использовать функции, которые вы написали в EX00.

## Упражнение 02: Охранная сигнализация
Вы написали несколько функций (`add_ingot(purse), get_ingot(purse)и empty(purse)`) для дизайна кошелька, но теперь вам нужно придумать способ добавить какое-то новое поведение ко всем из них — всякий раз, когда вызывается какая-либо из них, `SQUEAK` должно быть напечатано слово. Хитрость в том, что вы не можете изменить тело этих функций, но по-прежнему выдаете этот аларм. Подсказка: нужно использовать [decorator](<https://realpython.com/primer-on-python-decorators/>).

# День 02
## Упражнение 00: Получение доступа
```
AssertionError: len(key) == 1337
AssertionError: key[404] == 3
AssertionError: key > 9000
AssertionError: key.passphrase == "zax2rulez"
AssertionError: str(key) == "GeneralTsoKeycard"
```
Нужно описать класс Python `Key` так, чтобы экземпляр этого класса прошел перечисленные выше проверки. Имейте в виду, что ваш код в этом упражнении не должен создавать никаких контейнеров ни размером 404, ни меньше. Даже без него вы сможете пройти эти проверки.

Вам рекомендуется написать фактический набор тестов для имитации проверки ключей в соответствии с приведенными выше ошибками (и для упрощения экспертной проверки). Это оценивается как бонус.

## Упражнение 01: Мораль
Написать игру, как [эта](<https://ncase.me/trust/>)

# День 03
## Упражнение 00: Невинная шутка
Файл [evilcorp.html](d03/materials/evilcorp.html) в общей папке. Можно запустить `python3 -m http.server` этот файл в каталоге, чтобы протестировать нашу маленькую шутку в браузере. Просто открыть http://127.0.0.1:8000/evilcorp.html .
Трентон сразу показала на своем экране скрипт, который нужно было внедрить на веб-страницу:
``` 
<script>
        hacked = function() {
            alert('hacked');
        }
        window.addEventListener('load', 
          function() { 
            var f = document.querySelector("form");
            f.setAttribute("onsubmit", "hacked()");
          },
          false
        );
</script>
```
Нужно написать скрипт «exploit.py», который будет делать:
- изменить заголовок страницы (в `<title>` тегах) на «Evil Corp - Stealing your money every day».
- проанализировать имя пользователя со страницы (включая местоимение) и вставить новый тег `<h1>`
в a bodyстраницы, говоря `<h1>` Mr. Robot, you are hacked!`</h1>`
- внедрить скрипт Трентона в страницу
- ссылка в нижней части страницы теперь должна вести на « https://mrrobot.fandom.com/wiki/Fsociety » с фактическим названием компании на странице, замененным на «Fsociety».

Новый HTML-файл должен называться «evilcorp_hacked.html» и размещаться в том же каталоге, что и исходный файл «evilcorp.html».

## Упражнение 01: Денежный поток
нужно написать два скрипта - `producer.py` и `consumer.py`.
Производитель должен генерировать сообщения JSON следующим образом:
```
{
   "metadata": {
       "from": 1023461745,
       "to": 5738456434
   },
   "amount": 10000
}
```

# День 04
## Упражнение 00: Поток энергии
написать скрипт `energy.py` с функцией с именем `fix_wiring()`, которая должна принимать три итерации (вы можете проверить функциональность только с помощью списков) с именами `cables`, `sockets` и `plugs`. Эта функция не должна делать никаких предположений о длине этих итераций, которые могут быть разными. Он должен возвращать другую итерацию по строкам с такими командами, как:

`plug cable1 into socket1 using plug1` `weld cable2 to socket2 without plug`

Вы можете видеть, что единственный итератор, длина которого не имеет значения, это `plugs`, потому что в худшем случае кабели могут быть приварены к розеткам. Если кабелей или розеток не хватает, то ничего не поделаешь, поэтому их не должно быть в результирующем итераторе.

Это означает, что для такого кода:
```
plugs = ['plug1', 'plug2', 'plug3']
sockets = ['socket1', 'socket2', 'socket3', 'socket4']
cables = ['cable1', 'cable2', 'cable3', 'cable4']

for c in fix_wiring(cables, sockets, plugs):
    print(c)
```
вывод должен быть:
```
plug cable1 into socket1 using plug1
plug cable2 into socket2 using plug2
plug cable3 into socket3 using plug3
weld cable4 to socket4 without plug
```

## Упражнение 01: Личности
Рядом со столом лежал чертеж башни с функциональным описанием:
```
class: Turret
personality traits: neuroticism, openness, conscientiousness, extraversion, agreeableness
actions: shoot, search, talk
```

На чертеже также был кружок кофе, большое число 427 и имя «Стэнли», написанное в углу.

Нужно реализовать функцию генератора для турелей, вызываемую `turrets_generator()`в файле с именем `personality.py`. Хитрость заключается в том, что вам не следует описывать класс Turret отдельно (есть способ динамически сгенерировать как класс, так и экземпляр, `class` вообще не используя это слово).

Кроме того, три метода должны просто печатать "Shooting", "Searching" и "Talking" соответственно. Каждая черта личности должна быть случайным числом от 0 до 100, а сумма всех пяти для каждого экземпляра должна быть равна 100.

## Упражнение 02: Противодавление
Нужно создать файл `pressure.py` функции-генератора `emit_gel()`, который должен имитировать измеренное давление жидкости. Он должен генерировать бесконечный поток чисел от 50 до 100 (значения > 100 считаются ошибкой) со случайным шагом, выбранным из диапазона `[0, step]` где `step` аргумент генератора `emit_gel()`.

Необходимо следовать рекомендациям по контролю давления. Предполагается, что рабочее давление должно быть между 20 и 80, а это означает, что если генератор в какой-то момент выдает значение ниже 20 или выше 80, следует применить действие, которое изменит знак шага. Чтобы реализовать такой клапан, вам нужно написать еще одну функцию с именем `valve()`, которая будет перебирать значения `emit_gel()` и использовать `.send()` метод для изменения знака текущего шага.

Реализовать аварийный перерыв. Если давление выше 90 или ниже 10, `emit_gel()` генератор должен быть корректно закрыт, а скрипт должен выйти.

Выберите `step` так, чтобы ваш скрипт выполнялся в течение нескольких секунд перед выходом. Вы можете добавить задержку между «измерениями давления», чтобы не тратить слишком много ресурсов ЦП на создание и обработку последовательности.

# День 05
## Упражнение 00: Обмани меня один раз
На одном из экранов ТАРДИС появляется список видов с примерами:
```
Cyberman: John Lumic
Dalek: Davros
Judoon: Shadow Proclamation Convention 15 Enforcer
Human: Leonardo da Vinci
Ood: Klineman Halpen
Silence: Tasha Lem
Slitheen: Coca-Cola salesman
Sontaran: General Staal
Time Lord: Rassilon
Weeping Angel: The Division Representative
Zygon: Broton
```
Нужно реализовать сервер [WSGI](<https://wsgi.tutorial.codepoint.net/intro>) с оболочкой HTTP без использования каких-либо внешних зависимостей. Он должен прослушивать локальный порт 8888 и анализировать параметры GET из URL-адреса для любого названия вида, возвращающего вам JSON (это должен быть HTTP-код 200, также обратите внимание на соответствующий заголовок «Content-Type» и кодировку URL). Пример использования cURL может выглядеть так:
```
~$ curl http://127.0.0.1:8888/?species=Time%20Lord
{"credentials": "Rassilon"}
```
Если он не знает переданный вид, он должен вернуться `{"credentials": "Unknown"}` вместе с кодом состояния HTTP 404.

Все приложение для этой задачи должно состоять из одного файла `credentials.py`.

## Упражнение 01: Песня про отвертку
Нужно создать простое клиент-серверное приложение WSGI+HTTP для управления звуковыми файлами.

Во-первых, сервер. Он не должен использовать какую-либо базу данных, достаточно просто хранить файлы на диске. Веб-интерфейс должен работать на порту 8888. При открытии веб-страницы должен отображаться список уже загруженных звуковых файлов, а также кнопка для загрузки еще одного. Как пользователь, вы должны иметь возможность нажать на эту кнопку, загрузить файл на сервер, и он должен появиться в списке файлов, показанных на веб-странице.

Кроме того, сервер должен выполнять проверку [типа MIME](<https://en.wikipedia.org/wiki/Media_type>), поэтому принимаются только аудиофайлы (например `mp3`, `ogg` и `wav`). Если загружается не аудиофайл (например `jpg`, `exe` или `docx`), его следует удалить, а на веб-странице должно появиться сообщение «Обнаружен не аудиофайл».

За некоторые бонусные баллы вы можете реализовать воспроизведение загруженных звуковых файлов прямо с веб-страницы.

На этот раз вы не ограничены встроенным сервером WSGI, поэтому для этой задачи рекомендуется использовать фреймворк [Flask](<https://flask.palletsprojects.com/en/2.3.x/>) или [Django](<https://www.djangoproject.com/>), хотя это не является строгим требованием. Не забудьте добавить в файл любые сторонние зависимости, которые вы использовали `requirements.txt`. Пожалуйста, также включите файл `README`, объясняющий, как запустить HTTP-сервер (он должен содержать конкретную команду для запуска).
Во-вторых, клиент. Это должно быть приложение командной строки с двумя возможными действиями:

- `python screwdriver.py upload /path/to/file.mp3` следует загрузить локальный аудиофайл `/path/to/file.mp3` на сервер
- `python screwdriver.py list` должен получить и распечатать имена всех файлов, присутствующих в данный момент на сервере.

Все взаимодействие между клиентом и сервером должно осуществляться по протоколу HTTP. Рекомендуется (хотя и не является строго обязательным) использовать библиотеку [Requests](<https://docs.python-requests.org/en/latest/>) или [HTTPX](<https://www.python-httpx.org/>) для выполнения HTTP-запросов.

## Упражнение 02. Правильное время
У каждого Доктора в **правой** руке есть отвертка, но для действия требуется **минимум две**. Итак, чтобы получить два сразу, Доктор должен взять отвертку у другого Доктора слева. Но если это сделают все, то ничего особо не изменится, так как у каждого врача останется по одной отвертке.

Начните с представления врачей и отверток в виде классов Python. Врачи пронумерованы от 9 до 13, и каждый из них должен сделать один взрыв двумя отвертками.

*ПРИМЕЧАНИЕ:* это вариант известной задачи параллельного программирования, обычно называемой ["Обед философов"](<https://en.wikipedia.org/wiki/Dining_philosophers_problem>).

Вывод многопоточной программы должен выглядеть следующим образом:
```
Doctor 11: BLAST!
Doctor 9: BLAST!
Doctor 12: BLAST!
Doctor 10: BLAST!
Doctor 13: BLAST!
```
Порядок может быть разным при каждом запуске, потому что все Доктора (потоки) будут соревноваться друг с другом за следующий ход, чтобы схватить две отвертки. Сам код должен быть в файле `doctors.py`.

# День 06
## Упражнение 00: Отчет по Кирову
Основной протокол, используемый для межпространственной связи, назывался **«Protobuf 2.0»**. Записи отправлялись через транспорт под названием **«gRPC»**. Итак, это был первый слой, который Эндер должен был реализовать.

Поскольку gRPC — это инфраструктура связи клиент-сервер, необходимо было реализовать два компонента — «reporting_server.py» и «reporting_client.py». Сервер должен предоставить конечную точку потоковой передачи ответов, где он получает набор координат (Эндеру было разрешено использовать [любую конкретную систему](<https://en.wikipedia.org/wiki/Astronomical_coordinate_systems>), которая ему нравится), и отвечает потоком записей космического корабля.

Поскольку в настоящее время это тестовая среда, хотя каждый космический корабль должен иметь все упомянутые параметры, они могут быть случайными. Кроме того, они должны быть строго типизированы, например:
- Выравнивание - это перечисление
- Имя представляет собой строку
- Длина поплавка
- Класс - это перечисление
- Размер — целое число
- Вооруженный статус является логическим
- У каждого офицера на борту должно быть имя, фамилия и звание в виде строк.

Количество офицеров на борту — случайное число от 0 (только для вражеских кораблей) до 10.

Рабочий процесс должен быть таким:
1. сервер запущен
2. клиент запускается с заданным набором координат в выбранной форме, например:

`~$ ./reporting_client.py 17 45 40.0409 −29 00 28.118`

В качестве примера приведены галактические координаты для [Стрельца A](<https://en.wikipedia.org/wiki/Sagittarius_A*>) * 3) эти координаты отправляются на сервер, и сервер отвечает случайным (1-10) числом космических кораблей в потоке gRPC клиенту 4) клиент выводит на стандартный вывод все полученные данные отправляются в виде набора сериализованных строк JSON, например:
```
{
  "alignment": "Ally",
  "name": "Normandy",
  "class": "Corvette",
  "length": 216.3,
  "crew_size": 8,
  "armed": true,
  "officers": [{"first_name": "Alan", "last_name": "Shepard", "rank": "Commander"}]
}
{
  "alignment": "Enemy",
  "name": "Executor",
  "class": "Dreadnought",
  "length": 19000.0,
  "crew_size": 450,
  "armed": true,
  "officers": []
}
```
*ПРИМЕЧАНИЕ: этот вывод здесь отформатирован для удобочитаемости, ваш код все еще может печатать один JSON на строку.*

## Полезное
Многие операции уже представлены в виде методов в стандартной библиотеке, например, для строк вы можно обратиться [по этой ссылке](<https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str>).

Модуль [Python Argparse](<https://docs.python.org/3/howto/argparse.html>) для разбора аргументов командной строки. 

[Подсказки типов](<https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html>), краткая памятка, показывающая, как использовать аннотации типов для различных распространенных типов в Python

Также рекомендуется написать несколько тестов для различных случаев внутри ваших скриптов. Чтобы заставить их работать только тогда, когда скрипт выполняется напрямую, а не импортируется откуда-то еще, вы можете использовать if __name__ == \"__main__\":оператор. [Подробнее](<https://www.geeksforgeeks.org/what-does-the-if-__name__-__main__-do/>)

Небольшой [учебник](<https://ncase.me/trust/>) по теории игр

В Python есть несколько неизменяемых типов объектов. например, [замороженные наборы](<https://docs.python.org/3/library/stdtypes.html#frozenset>).

Python имеет встроенный способ изменения поведения функций без прямого изменения их кода. Он называется a [decorator](<https://realpython.com/primer-on-python-decorators/>) и представляет собой просто специальный синтаксис для функции, которая принимает функцию в качестве аргумента и возвращает функцию. 
