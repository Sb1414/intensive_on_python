# intensive_on_python
решение задач на python

# Оглавление
1. [День 00](#день-00) \
    [Упражнение 00: Блокчейн](#упражнение-00-блокчейн)\
    [Упражнение 01: Расшифровка](#упражнение-01-расшифровка)\
    [Упражнение 02. Отслеживание и захват](#упражнение-02-отслеживание-и-захват)
2. [День 01](#день-01)\
    [Упражнение 00: Функциональный кошелек](#упражнение-00-функциональный-кошелек)\
    [Упражнение 01: Расщепление](#упражнение-01-расщепление)

# День 00
## Упражнение 00: Блокчейн
Дан [файл](d00/data_hashes_10lines.txt), с несколькими строками. Некоторые строки начинаются с нескольких нулей. Нужно написать Python-скрипт, который сможет получать текст со своего стандартного ввода, а затем выводить только те строки, которые начинаются ровно с 5 нулей и строка имеет длину 32 символа. Строка, начинающаяся с 6 нулей, НЕ считается правильной.

Код должен принимать количество строк в качестве аргумента, например:
```
~$ cat data_hashes_10lines.txt | python blocks.py 10
```
Таким образом, программа остановится, когда обработает 10 строк. 

## Упражнение 01: Расшифровка
Электронные письма состояли из каких-то странных текстов, таких как "The only way everyone reaches Brenda rapidly is delivering groceries explicitly" или "Britain is Great because everyone necessitates". Написать скрипт на Python, который можно использовать для расшифровки подобных сообщений и распечатать ответ одним словом без пробелов. Он должен запускаться следующим образом:
```
~$ python decypher.py \"Have you delivered eggplant pizza at restored keep?\"
```

## Упражнение 02. Отслеживание и захват
В качестве входных данных коду дается двумерное «изображение» в виде текста в файле m.txt. Файл содержит пять символов в трех строках, например:
```
*d&t*
**h**
*l*!*
```
Есть шаблон из звезд с буквой M. Все, что нужно сделать — это напечатать «True», если этот M-шаблон существует в заданном входном изображении, или «False» в противном случае. Другие символы (за пределами шаблона M) должны быть другими, поэтому в этих примерах должно быть напечатано «False»:
```
*****
*****
*****
```
```
*s*f*
**f**
*a***
```
Если данный шаблон не 3x5, то вместо него должно быть напечатано слово «Error». Файл с кодом должен называться mfinder.py.

# День 01
## Упражнение 00: Функциональный кошелек
нужно написать функции `add_ingot(purse)`, `get_ingot(purse)`которые `empty(purse)` принимают кошелек (словарь, строго говоря, a `typing.Dict[str, int]`) и возвращают кошелек (пустой dict в случае `empty(purse)`). Им не следует делать предположений о содержимом кошелька (он может быть пустым или хранить что-то совсем другое, например «stones»).

Кроме того, ваши функции не должны иметь побочных эффектов. Это означает, что объект, переданный в качестве аргумента, не должен изменяться внутри функции. Вместо этого должен быть возвращен новый объект. Таким образом, *вам не следует использовать код, написанный Томом*, так как он делает *прямое присвоение* полю внутри кошелька. Вместо этого вы должны вернуть *новый экземпляр dict* с обновленным номером внутри него.

Итак, композиция функций вроде `add_ingot(get_ingot(add_ingot(empty(purse))))` должна возвращать `{\"gold_ingots\": 1}`. Кроме того, получение слитка из пустого кошелька не должно приводить к ошибке и должно просто возвращать пустой кошелек.

Примечание: в этой задаче нас интересуют только золотые слитки, так что не имеет особого значения, что будет с остальными вещами внутри кошелька. Вы можете сохранить его или выбросить.

## Упражнение 01: Расщепление
Вам нужно написать функцию с именем `split_booty`, которая будет принимать любое количество кошельков (словарей) в качестве аргументов. Кошельки в аргументах могут содержать различные предметы, но наших почетных деятелей интересуют только золотые слитки (названные, `gold_ingots` как в примерах выше). Количество слитков может быть нулевым или целым положительным числом.

Эта функция должна вернуть назад три кошелька (словаря) так, чтобы в любых двух из трех кошельков разница между количеством слитков была не больше 1. Например, если в добыче есть , и , то `{"gold_ingots":3}` функция `{"gold_ingots":2}` должна `{"apples":10}` вернуть `({"gold_ingots": 2}, {"gold_ingots": 2}, {"gold_ingots": 1})`.

При реализации этой функции вы все равно не должны использовать прямое присвоение полей внутри словарей. Вместо этого вы можете повторно использовать функции, которые вы написали в EX00.



## Полезное
Многие операции уже представлены в виде методов в стандартной библиотеке, например, для строк вы можно обратиться [по этой ссылке](<https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str>).

Модуль [Python Argparse](<https://docs.python.org/3/howto/argparse.html>) для разбора аргументов командной строки. 

[Подсказки типов](<https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html>), краткая памятка, показывающая, как использовать аннотации типов для различных распространенных типов в Python

Также рекомендуется написать несколько тестов для различных случаев внутри ваших скриптов. Чтобы заставить их работать только тогда, когда скрипт выполняется напрямую, а не импортируется откуда-то еще, вы можете использовать if __name__ == \"__main__\":оператор. [Подробнее](<https://www.geeksforgeeks.org/what-does-the-if-__name__-__main__-do/>)

Небольшой [учебник](<https://ncase.me/trust/>) по теории игр
